<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="是我"><title>最大流 | CS</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '40ce7ce9cf2783418f371022c3e6a2bf';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
  </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">最大流</h1><a id="logo" href="/.">CS</a><p class="description">ljr的小bk</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/messageboard/"><i class="fa null"> 留言板</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">最大流</h1><div class="post-meta">Jan 14, 2019<span> | </span><span class="category"><a href="/categories/算法/">算法</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#预备知识"><span class="toc-number">1.</span> <span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个前提"><span class="toc-number">2.</span> <span class="toc-text">两个前提</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#（1）容量约束"><span class="toc-number">2.1.</span> <span class="toc-text">（1）容量约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（2）流量守恒"><span class="toc-number">2.2.</span> <span class="toc-text">（2）流量守恒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ford-Fulkerson算法（增广路算法）"><span class="toc-number">3.</span> <span class="toc-text">Ford-Fulkerson算法（增广路算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增流"><span class="toc-number">3.2.</span> <span class="toc-text">增流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增广路算法"><span class="toc-number">3.3.</span> <span class="toc-text">增广路算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短增广路算法"><span class="toc-number">3.4.</span> <span class="toc-text">最短增广路算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板"><span class="toc-number">3.5.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重贴标签算法（Improved-Shortest-Augument-Path，ISAP）"><span class="toc-number">4.</span> <span class="toc-text">重贴标签算法（Improved Shortest Augument Path，ISAP）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤"><span class="toc-number">4.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板-1"><span class="toc-number">4.2.</span> <span class="toc-text">模板</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul>
<li>网络：一个有向带权图，包含一个源点和一个汇点，没有反平行边（如果$v_1$和$v_2$之间有边，那么要么是$(v_1,v_2)$，要么是$(v_2,v_1)$，两个不会同时存在）。</li>
<li>网络流：网络流即网络上的流，是定义在网络边集$E$上的一个非负函数$flow={flow(u,v)}$，$flow(u,v)$是边上的流量。</li>
<li>网络最大流：在满足下面两个前提情况下，在流网络中找到一个净输出最大的网络流。</li>
</ul>
<hr>
<h2 id="两个前提"><a href="#两个前提" class="headerlink" title="两个前提"></a>两个前提</h2><h3 id="（1）容量约束"><a href="#（1）容量约束" class="headerlink" title="（1）容量约束"></a>（1）容量约束</h3><p>对于所有节点u和v，满足实际流量不大于最大可容纳流量，即：$0\leq flow(u,v)\leq cap(u,v)$。</p>
<h3 id="（2）流量守恒"><a href="#（2）流量守恒" class="headerlink" title="（2）流量守恒"></a>（2）流量守恒</h3><p>除了源点s和汇点t外，任意节点u都满足流入量等于流出量，即：$\sum_{(x,u)\in E}flow(x,u)=\sum_{(u,y)\in E}flow(u,y)$。</p>
<ul>
<li><p>对于源点s，净输出值=流出量之和-流入量之和</p>
</li>
<li><p>对于汇点t，净输入值=流入量之和-流出量之和</p>
</li>
<li><p>净输出值=净输入值</p>
</li>
</ul>
<hr>
<h2 id="Ford-Fulkerson算法（增广路算法）"><a href="#Ford-Fulkerson算法（增广路算法）" class="headerlink" title="Ford-Fulkerson算法（增广路算法）"></a>Ford-Fulkerson算法（增广路算法）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>初始网络$G$:一般体现输入的网络。</p>
</li>
<li><p>实流网络$G’$：体现当前实际流量的网络。</p>
</li>
<li><p>残余网络$G^<em>$：$G^</em>$和$G$的节点集相同，而网络$G$中对应$G^*$中的一条边或两条边。<strong>在残余网络中，与网络边对应的同向边是可增量（即还可以增加多少流量），反向边是实际流量</strong>。</p>
</li>
<li><p>可增广路：残余网络$G^*$中一条从源点s到汇点t的简单路径。</p>
</li>
<li><p>可增广量：可增广路上每条边的可增量的最小值。</p>
</li>
<li><p>求最大流：先在残余网络中找可增广路，然后在实流网络中增流，再在残余网络中减流。持续上述过程直至找不到可增广路。这时的实流网络就是最大流网络。</p>
</li>
</ul>
<h3 id="增流"><a href="#增流" class="headerlink" title="增流"></a>增流</h3><ol>
<li><p>沿可增广路找最小值作为可增广量d。在<strong>实流网络</strong>中沿着可增广路<strong>增流</strong>：可增广路上<em>同向边</em>增加流量d，<em>反向边</em>减少流量d。</p>
</li>
<li><p>在<strong>残余网络</strong>中沿着可增广路<strong>减流</strong>：可增广路上的<em>同向边</em>减少流量d，<em>反向边</em>增加流量d。</p>
</li>
</ol>
<h3 id="增广路算法"><a href="#增广路算法" class="headerlink" title="增广路算法"></a>增广路算法</h3><blockquote>
<p>增广路定理：设flow是网络G的一个可行流，如果不存在从源点s到汇点t关于flow的可增广路p，则flow是G的一个增广路。</p>
</blockquote>
<p>增广路算法其实不是一种算法，而是一种方法，因为Ford-Fulkerson并没有说明如何找可增广路，而找增广路的算法不同，算法的时间复杂度相差很大。</p>
<h3 id="最短增广路算法"><a href="#最短增广路算法" class="headerlink" title="最短增广路算法"></a>最短增广路算法</h3><p>如何找到一条可增广路？可以设置最大容量优先，也可以是最短路径（广度优先）优先。Edmonds-Karp算法就是以广度优先的增广路算法，又称为最短增广路算法（Shortest Augument Path,SAP）。</p>
<p>步骤如下：</p>
<p>采用队列$q$来存放已访问未检查的节点。布尔数组$vis[]$标识节点是否被访问过，$pre[]$数组记录可增广路上节点的前驱，$pre[v]=u$表示可增广路上$v$节点的前驱是$u$，最大流值$maxflow=0$。</p>
<ul>
<li>初始化可行流$flow$为零流，即实流网络中全是零流边，残余网络中全是最大容量边（可增量）。初始化$vis[]$数组为$false$，$pre[]$数组为-1。</li>
<li>令$vis[s]=true$，$s$加入队列$q$。</li>
<li>如果队列不为空，继续下一步，否则算法结束，找不到可增广路。当前的实流网络就是最大流网络，返回最大流值$maxflow$。</li>
<li>队头元素$new$出队，在残余网络中检查$new$的所有邻接节点$i$。如果未被访问，则访问之，令$vis[i]=true$,$pre[i]=new$；如果$i=t$，说明已到达汇点，找到一条可增广路，转向第五步；否则节点$i$加入队列$q$，转向第三步。</li>
<li>从汇点开始，通过前驱数组$pre[]$，逆向找可增广路上每条边值的最小值，即可增量$d$。</li>
<li>在实流网络中增流，在残余网络中减流，$Maxflow+=d$，转向第二步。</li>
</ul>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">//program 7-2</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 100; //最大顶点数</span><br><span class="line">const int INF = (1&lt;&lt;30)-1;</span><br><span class="line">int g[maxn][maxn]; //残余网络（初始时各边为容量）</span><br><span class="line">int f[maxn][maxn]; //实流网络（初始时各边为0流）</span><br><span class="line">int pre[maxn]; //前驱数组</span><br><span class="line">bool vis[maxn];//访问数组</span><br><span class="line">int n,m; //顶点个数n和边的数量m</span><br><span class="line"></span><br><span class="line">bool bfs(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    vis[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n; i++)//寻找可增广路</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;g[now][i]&gt;0)//未被访问且有边相连</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = true;</span><br><span class="line">                pre[i] = now;</span><br><span class="line">                if(i==t)  return true;//找到一条可增广路</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;//找不到可增广路</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EK(int s, int t)</span><br><span class="line">&#123;</span><br><span class="line">    int v,w,d,maxflow;</span><br><span class="line">    maxflow = 0;</span><br><span class="line">    while(bfs(s,t))//可以增广</span><br><span class="line">    &#123;</span><br><span class="line">        v=t;</span><br><span class="line">        d=INF;</span><br><span class="line">        while(v!=s)//找可增量d</span><br><span class="line">        &#123;</span><br><span class="line">            w=pre[v];//w记录v的前驱</span><br><span class="line">            if(d&gt;g[w][v])</span><br><span class="line">                d=g[w][v];</span><br><span class="line">            v=w;</span><br><span class="line">        &#125;</span><br><span class="line">        maxflow+=d;</span><br><span class="line">        v=t;</span><br><span class="line">        while(v!=s)//沿可增广路增流</span><br><span class="line">        &#123;</span><br><span class="line">            w=pre[v];</span><br><span class="line">            g[w][v]-=d;  //残余网络中正向边减流</span><br><span class="line">            g[v][w]+=d;  //残余网络中反向边增流</span><br><span class="line">            if(f[v][w]&gt;0) //实流网络中如果是反向边,则减流,否则正向边增流</span><br><span class="line">                f[v][w]-=d;</span><br><span class="line">            else</span><br><span class="line">                f[w][v]+=d;</span><br><span class="line">            v=w;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxflow;</span><br><span class="line">&#125;</span><br><span class="line">void print()//输出实流网络</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;----------实流网络如下：----------&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;  &quot;;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">       cout&lt;&lt;setw(7)&lt;&lt;&quot;v&quot;&lt;&lt;i;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;v&quot;&lt;&lt;i;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">           cout&lt;&lt;setw(7)&lt;&lt;f[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int u,v,w;</span><br><span class="line">    memset(g,0,sizeof(g));//残余网络初始化为0</span><br><span class="line">    memset(f,0,sizeof(f));//实流网络初始化为0</span><br><span class="line">    cout&lt;&lt;&quot;请输入结点个数n和边数m:&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cout&lt;&lt;&quot;请输入两个结点u,v及边(u--v)的容量w:&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        g[u][v]+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;网络的最大流值:&quot;&lt;&lt;EK(1,n)&lt;&lt;endl;</span><br><span class="line">    print();//输出实流网络</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重贴标签算法（Improved-Shortest-Augument-Path，ISAP）"><a href="#重贴标签算法（Improved-Shortest-Augument-Path，ISAP）" class="headerlink" title="重贴标签算法（Improved Shortest Augument Path，ISAP）"></a>重贴标签算法（Improved Shortest Augument Path，ISAP）</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>确定合适的数据结构，采用邻接表存储网络。</li>
<li>对网络节点贴标签，即标高操作。</li>
<li>如果源点的高度$\ge$节点数，则转向第六步；否则从源点开始，沿着高度h(u)=h(v)+1且有可行邻接边(cap&gt;flow)的方向前进，如果到达汇点，则转向第四步；如果无法行进，则转向第五步。</li>
<li>增流操作：沿着找到的增广路同向边增流，反向边减流。注意：在原网络上操作。</li>
<li>重贴标签：如果拥有当前节点高度的节点只有一个，则转向第六步；令当前节点的高度=所有邻接点高度的最小值+1；如果没有可行邻接边，则令当前节点的高度=节点数；退回一步；转向第三部。</li>
<li>算法结束，已找到最大流。</li>
</ul>
<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">//program 7-2-1 ISAP算法优化</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int inf = 0x3fffffff;</span><br><span class="line">const int N=100;</span><br><span class="line">const int M=10000;</span><br><span class="line">int top;</span><br><span class="line">int h[N], pre[N], g[N];</span><br><span class="line"></span><br><span class="line">struct Vertex</span><br><span class="line">&#123;</span><br><span class="line">   int first;</span><br><span class="line">&#125;V[N];</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">   int v, next;</span><br><span class="line">   int cap, flow;</span><br><span class="line">&#125;E[M];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    memset(V, -1, sizeof(V));</span><br><span class="line">    top = 0;</span><br><span class="line">&#125;</span><br><span class="line">void add_edge(int u, int v, int c)</span><br><span class="line">&#123;</span><br><span class="line">    E[top].v = v;</span><br><span class="line">    E[top].cap = c;</span><br><span class="line">    E[top].flow = 0;</span><br><span class="line">    E[top].next = V[u].first;</span><br><span class="line">    V[u].first = top++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u,int v, int c)</span><br><span class="line">&#123;</span><br><span class="line">    add_edge(u,v,c);</span><br><span class="line">    add_edge(v,u,0);</span><br><span class="line">&#125;</span><br><span class="line">void set_h(int t,int n)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt; Q;</span><br><span class="line">    memset(h, -1, sizeof(h));</span><br><span class="line">    memset(g, 0, sizeof(g));</span><br><span class="line">    h[t] = 0;</span><br><span class="line">    Q.push(t);</span><br><span class="line">    while(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">       int v = Q.front(); Q.pop();</span><br><span class="line">       ++g[h[v]];</span><br><span class="line">       for(int i = V[v].first; ~i; i = E[i].next)</span><br><span class="line">       &#123;</span><br><span class="line">          int u = E[i].v;</span><br><span class="line">          if(h[u] == -1)</span><br><span class="line">          &#123;</span><br><span class="line">             h[u] = h[v] + 1;</span><br><span class="line">             Q.push(u);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;初始化高度&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;h[ ]=&quot;;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">       cout&lt;&lt;&quot;  &quot;&lt;&lt;h[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int Isap(int s, int t,int n)</span><br><span class="line">&#123;</span><br><span class="line">    set_h(t,n);</span><br><span class="line">    int ans=0, u=s;</span><br><span class="line">    int d;</span><br><span class="line">    while(h[s]&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        int i=V[u].first;</span><br><span class="line">        if(u==s)</span><br><span class="line">           d=inf;</span><br><span class="line">        for(; ~i; i=E[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">           int v=E[i].v;</span><br><span class="line">           if(E[i].cap&gt;E[i].flow &amp;&amp; h[u]==h[v]+1)</span><br><span class="line">           &#123;</span><br><span class="line">                u=v;</span><br><span class="line">                pre[v]=i;</span><br><span class="line">                d=min(d, E[i].cap-E[i].flow);</span><br><span class="line">                if(u==t)</span><br><span class="line">                &#123;</span><br><span class="line">                   cout&lt;&lt;endl;</span><br><span class="line">                   cout&lt;&lt;&quot;增广路径：&quot;&lt;&lt;t;</span><br><span class="line">                   while(u!=s)</span><br><span class="line">                   &#123;</span><br><span class="line">                       int j=pre[u];</span><br><span class="line">                       E[j].flow+=d;</span><br><span class="line">                       E[j^1].flow-=d;</span><br><span class="line">                       u=E[j^1].v;</span><br><span class="line">                       cout&lt;&lt;&quot;--&quot;&lt;&lt;u;</span><br><span class="line">                   &#125;</span><br><span class="line">                   cout&lt;&lt;&quot;增流：&quot;&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">                   ans+=d;</span><br><span class="line">                   d=inf;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==-1)</span><br><span class="line">        &#123;</span><br><span class="line">           if(--g[h[u]]==0)</span><br><span class="line">              break;</span><br><span class="line">           int hmin=n-1;</span><br><span class="line">           //cur[u]=V[u].first;</span><br><span class="line">           for(int j=V[u].first; ~j; j=E[j].next)</span><br><span class="line">              if(E[j].cap&gt;E[j].flow)</span><br><span class="line">                 hmin=min(hmin, h[E[j].v]);</span><br><span class="line">           h[u]=hmin+1;</span><br><span class="line">           cout&lt;&lt;&quot;重贴标签后高度&quot;&lt;&lt;endl;</span><br><span class="line">           cout&lt;&lt;&quot;h[ ]=&quot;;</span><br><span class="line">           for(int i=1;i&lt;=n;i++)</span><br><span class="line">              cout&lt;&lt;&quot;  &quot;&lt;&lt;h[i];</span><br><span class="line">           cout&lt;&lt;endl;</span><br><span class="line">           ++g[h[u]];</span><br><span class="line">           if(u!=s)</span><br><span class="line">              u=E[pre[u]^1].v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void printg(int n)//输出网络邻接表</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;&quot;----------网络邻接表如下：----------&quot;&lt;&lt;endl;</span><br><span class="line">   for(int i=1;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;&quot;v&quot;&lt;&lt;i&lt;&lt;&quot;  [&quot;&lt;&lt;V[i].first;</span><br><span class="line">       for(int j=V[i].first;~j;j=E[j].next)</span><br><span class="line">           cout&lt;&lt;&quot;]--[&quot;&lt;&lt;E[j].v&lt;&lt;&quot;   &quot;&lt;&lt;E[j].cap&lt;&lt;&quot;   &quot;&lt;&lt;E[j].flow&lt;&lt;&quot;   &quot;&lt;&lt;E[j].next;</span><br><span class="line">       cout&lt;&lt;&quot;]&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void printflow(int n)//输出实流边</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;&quot;----------实流边如下：----------&quot;&lt;&lt;endl;</span><br><span class="line">   for(int i=1;i&lt;=n;i++)</span><br><span class="line">     for(int j=V[i].first;~j;j=E[j].next)</span><br><span class="line">        if(E[j].flow&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">           cout&lt;&lt;&quot;v&quot;&lt;&lt;i&lt;&lt;&quot;--&quot;&lt;&lt;&quot;v&quot;&lt;&lt;E[j].v&lt;&lt;&quot;   &quot;&lt;&lt;E[j].flow;</span><br><span class="line">           cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    cout&lt;&lt;&quot;请输入结点个数n和边数m:&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    cout&lt;&lt;&quot;请输入两个结点u,v及边(u--v)的容量w:&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    printg(n);//输出初始网络邻接表</span><br><span class="line">    cout&lt;&lt;&quot;网络的最大流值:&quot;&lt;&lt;Isap(1,n,n)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    printg(n);//输出最终网络</span><br><span class="line">    printflow(n);//输出实流边</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/图论/">图论</a></div><div class="post-nav"><a class="pre" href="/2019/01/18/稳定婚姻问题/">稳定婚姻问题</a><a class="next" href="/2019/01/10/最大团/">最大团</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '0483208eb2e3e97a0867',
  clientSecret: '87809b59419dd27eaa0d3ce977a74c7f85a86617',
  repo: 'comment',
  owner: 'luojinrong',
  admin: ['luojinrong'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://luojinrong.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/STL使用/">STL使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具使用/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/题解/">题解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具使用/" style="font-size: 15px;">工具使用</a> <a href="/tags/hdu/" style="font-size: 15px;">hdu</a> <a href="/tags/计蒜客/" style="font-size: 15px;">计蒜客</a> <a href="/tags/趣学算法/" style="font-size: 15px;">趣学算法</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/nowcode/" style="font-size: 15px;">nowcode</a> <a href="/tags/codeforces/" style="font-size: 15px;">codeforces</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/图论/" style="font-size: 15px;">图论</a> <a href="/tags/数论/" style="font-size: 15px;">数论</a> <a href="/tags/dp/" style="font-size: 15px;">dp</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/2019-Multi-University-Training-Contest-5/">2019 Multi-University Training Contest 5</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/2019牛客暑期多校训练营第五场/">2019牛客暑期多校训练营第五场</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/2019-Multi-University-Training-Contest-4/">2019 Multi-University Training Contest 4</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/VIM配置笔记/">VIM配置笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/Win10-Ubuntu双系统安装指南/">Win10+Ubuntu双系统安装指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/29/2019-Multi-University-Training-Contest-3/">2019 Multi-University Training Contest 3</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/29/2019牛客暑期多校训练营第四场/">2019牛客暑期多校训练营第四场</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/26/2019-Multi-University-Training-Contest-2/">2019 Multi-University Training Contest 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/26/2019-Multi-University-Training-Contest-1/">2019 Multi-University Training Contest 1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/26/2019牛客暑期多校训练营第三场/">2019牛客暑期多校训练营第三场</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/luojinrong/" title="我的GitHub" target="_blank">我的GitHub</a><ul></ul><a href="https://freshwlnd.github.io/" title="小基佬" target="_blank">小基佬</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">CS.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>